"""CodeSensei CLI — AI-powered coding challenges in your terminal."""

import os
import subprocess
import tempfile
import time
from typing import Optional

import typer
from rich.prompt import Confirm, Prompt

from codesensei_cli.api_client import APIError, api
from codesensei_cli.config import (
    clear_auth,
    get_username,
    is_logged_in,
    save_auth,
)
from codesensei_cli.display import (
    console,
    print_challenge_detail,
    print_daily_table,
    print_error,
    print_hint,
    print_info,
    print_review_challenge,
    print_stats,
    print_submission_result,
    print_success,
    print_welcome,
)

app = typer.Typer(
    name="codesensei",
    help="CodeSensei — AI-powered coding challenges in your terminal.",
    no_args_is_help=True,
    rich_markup_mode="rich",
)

# Track current solve session state
_solve_state: dict = {}


def _require_login() -> None:
    """Ensure the user is logged in before proceeding."""
    if not is_logged_in():
        print_error("Not logged in. Run: [bold]codesensei login[/bold]")
        raise typer.Exit(1)


@app.command()
def login(
    api_url: Optional[str] = typer.Option(None, "--api-url", help="Backend API URL"),
) -> None:
    """Authenticate with the CodeSensei backend."""
    if api_url:
        from codesensei_cli.config import save_config
        save_config({"api_url": api_url})

    console.print("\n[bold yellow]\u2694\ufe0f CodeSensei Login[/bold yellow]\n")

    # Check if user wants to register or login
    is_new = Confirm.ask("Are you a new user?", default=False)

    username = Prompt.ask("[bold]Username[/bold]")
    password = Prompt.ask("[bold]Password[/bold]", password=True)

    try:
        if is_new:
            email = Prompt.ask("[bold]Email[/bold]")
            result = api.register(username, email, password)
            print_success(f"Account created! Welcome, {username}!")
        else:
            result = api.login(username, password)
            print_success(f"Welcome back, {username}!")

        save_auth(
            token=result["token"],
            user_id=result["user_id"],
            username=result["username"],
        )
    except APIError as e:
        print_error(e.detail)
        raise typer.Exit(1)


@app.command()
def logout() -> None:
    """Log out and clear stored credentials."""
    clear_auth()
    print_success("Logged out.")


@app.command()
def daily() -> None:
    """Show today's challenges."""
    _require_login()

    username = get_username() or "Coder"
    print_welcome(username)
    console.print()

    try:
        data = api.get_daily()
    except APIError as e:
        print_error(e.detail)
        raise typer.Exit(1)

    challenges = data.get("challenges", [])
    if challenges:
        print_daily_table(challenges)
        console.print(
            "\n[dim]Run [bold]codesensei solve <ID>[/bold] to start a challenge.[/dim]"
        )
    else:
        tracks = data.get("tracks", [])
        if tracks:
            print_info("No challenges generated yet today. Available tracks:")
            for t in tracks:
                console.print(
                    f"  {t.get('track_icon', '')} [bold]{t['track_name']}[/bold] "
                    f"(Recommended difficulty: {t['recommended_difficulty']})"
                )
            console.print(
                "\n[dim]Challenges will appear once generated by the backend.[/dim]"
            )
        else:
            print_info("No tracks configured yet.")


@app.command()
def solve(
    challenge_id: int = typer.Argument(..., help="Challenge ID to solve"),
) -> None:
    """
    Solve a challenge interactively.

    Opens your editor for code challenges or accepts inline input for quizzes.
    """
    _require_login()

    # Fetch the challenge
    try:
        challenge = api.get_challenge(challenge_id)
    except APIError as e:
        print_error(e.detail)
        raise typer.Exit(1)

    # Display the challenge
    print_challenge_detail(challenge)

    # Store state for hint command
    global _solve_state
    _solve_state = {"challenge_id": challenge_id, "hints_used": 0}

    challenge_type = challenge.get("type", "code")
    start_time = time.time()

    if challenge_type == "quiz":
        # Inline input for quizzes
        answer = Prompt.ask("\n[bold]Your answer[/bold]")
    else:
        # Open editor for code challenges
        console.print(
            "\n[dim]Opening your editor... Write your solution, save, and close.[/dim]"
        )

        # Determine file extension based on track
        ext = ".py"
        track = challenge.get("track", "")
        if "java" in track:
            ext = ".java"
        elif "automation" in track:
            ext = ".sh"

        # Create temp file with boilerplate comment
        with tempfile.NamedTemporaryFile(
            mode="w",
            suffix=ext,
            prefix="codesensei_",
            delete=False,
        ) as tmp:
            tmp.write(f"# CodeSensei Challenge: {challenge.get('title', '')}\n")
            tmp.write(f"# Type: {challenge_type} | Difficulty: {challenge.get('difficulty', '?')}\n")
            tmp.write("# Write your solution below:\n\n")
            tmp_path = tmp.name

        editor = os.environ.get("EDITOR", "nano")
        try:
            subprocess.run([editor, tmp_path], check=True)
        except FileNotFoundError:
            # Fallback: prompt for input if editor not available
            print_info(f"Editor '{editor}' not found. Enter your solution below:")
            print_info("(Press Enter twice to finish)")
            lines = []
            while True:
                line = input()
                if line == "" and lines and lines[-1] == "":
                    break
                lines.append(line)
            answer = "\n".join(lines)
            os.unlink(tmp_path)
        else:
            # Read the file
            with open(tmp_path) as f:
                answer = f.read()
            os.unlink(tmp_path)

    elapsed = int(time.time() - start_time)
    hints_used = _solve_state.get("hints_used", 0)

    # Submit
    console.print("\n[dim]Submitting...[/dim]")
    try:
        result = api.submit_challenge(
            challenge_id=challenge_id,
            answer=answer,
            hints_used=hints_used,
            time_taken=elapsed,
        )
    except APIError as e:
        print_error(e.detail)
        raise typer.Exit(1)

    console.print()
    print_submission_result(result)

    _solve_state = {}


@app.command()
def hint(
    challenge_id: Optional[int] = typer.Argument(None, help="Challenge ID (uses current solve session if omitted)"),
) -> None:
    """Get a hint for a challenge."""
    _require_login()

    global _solve_state

    cid = challenge_id or _solve_state.get("challenge_id")
    if cid is None:
        print_error("No active challenge. Pass a challenge ID or start solving one.")
        raise typer.Exit(1)

    hint_num = _solve_state.get("hints_used", 0) + 1

    try:
        data = api.get_hint(cid, hint_num)
    except APIError as e:
        print_error(e.detail)
        raise typer.Exit(1)

    print_hint(data)
    _solve_state["hints_used"] = hint_num


@app.command()
def stats() -> None:
    """Show your progress overview — XP, levels, streaks, and weekly activity."""
    _require_login()

    try:
        overview = api.get_overview()
        weekly = api.get_weekly()
    except APIError as e:
        print_error(e.detail)
        raise typer.Exit(1)

    print_stats(overview, weekly)


@app.command()
def review() -> None:
    """Review a random previously-failed challenge."""
    _require_login()

    try:
        data = api.get_review()
    except APIError as e:
        print_error(e.detail)
        raise typer.Exit(1)

    if "message" in data and "id" not in data:
        print_info(data["message"])
        return

    print_review_challenge(data)

    # Offer to try again
    if Confirm.ask("\nWant to try this challenge again?", default=True):
        solve(data["id"])


def main() -> None:
    app()


if __name__ == "__main__":
    main()
